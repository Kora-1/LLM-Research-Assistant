from langgraph.graph import StateGraph, END
from langchain_core.runnables import RunnableConfig
from typing import TypedDict, List, Dict

# Importing the agent functions responsible for research and answering
from agents.research_agent import research_agent
from agents.answer_agent import answer_agent


# Define the state schema for the graph, using TypedDict to define a structured state
class GraphState(TypedDict):
    """
    A schema for the state used in the graph, defining the expected structure
    of the state dictionary that flows through the nodes.

    Attributes:
    - query (str): The research query to be answered.
    - summaries (List[Dict[str, str]]): A list of research summaries, each containing
      a URL and its corresponding summary.
    - final_answer (str): The final answer generated by the answer agent, after research is completed.
    """
    query: str
    summaries: List[Dict[str, str]]
    final_answer: str


def build_graph():
    """
    Builds and configures the StateGraph for the research and answering workflow.

    This function creates a state graph with two main nodes:
    - 'ResearchAgent': Responsible for gathering research summaries based on the query.
    - 'AnswerAgent': Takes the research summaries and provides a detailed answer.

    The graph is configured with the following steps:
    - The entry point is set to the 'ResearchAgent', which starts the process.
    - An edge is created from 'ResearchAgent' to 'AnswerAgent', allowing the research results
      to be passed to the answering agent.
    - An edge is created from 'AnswerAgent' to END, which terminates the workflow.

    Returns:
    - StateGraph: The compiled state graph that defines the flow of the research and answering process.

    Example:
    >>> graph = build_graph()
    >>> compiled_graph = graph.compile()
    """
    # Initialize a StateGraph with the specified state schema (GraphState)
    graph = StateGraph(GraphState)

    # Add nodes to the graph for the two agents: research agent and answer agent
    graph.add_node("ResearchAgent", research_agent)
    graph.add_node("AnswerAgent", answer_agent)

    # Set the entry point to be the 'ResearchAgent', which will start the workflow
    graph.set_entry_point("ResearchAgent")

    # Add edges to define the flow of the process:
    # From 'ResearchAgent' to 'AnswerAgent'
    graph.add_edge("ResearchAgent", "AnswerAgent")
    # From 'AnswerAgent' to END (this marks the end of the workflow)
    graph.add_edge("AnswerAgent", END)

    # Compile and return the graph configuration
    return graph.compile()
